package akogen

import (
	"errors"
	"fmt"
	"path/filepath"
	"reflect"

	"github.com/dave/jennifer/jen"
)

var (
	// ErrorNilSpec code spec cannot be nil
	ErrNilSpec = errors.New("code specification cannot be nil")

	// ErrorEmptySpec code spec cannot be empty
	ErrEmptySpec = errors.New("code specification cannot be empty")

	// CodeGenBanner is a notice for generated code files
	CodeGenBanner = "Generated by AKOGen code Generator - do not edit"
)

const (
	// Auto is a setting that gets automatically overridden by a sane default
	Auto = ""

	// DefaultExternalNameAtlas is the default external name
	DefaultExternalNameAtlas = "ExternalSystem"

	// DefaultAPIField name
	DefaultAPIField = "api"

	// DefaultWrapperField name
	DefaultWrapperField = "w"

	// DefaultExternalField name
	DefaultExternalField = "external"

	// DefaultInternalField name
	DefaultInternalField = "internal"
)

var DefaultSettings = TranslationLayerSettings{
	ExternalName:  DefaultExternalNameAtlas,
	ImportAlias:   Auto,
	APIField:      DefaultAPIField,
	WrapperField:  DefaultWrapperField,
	WrapperType:   Auto,
	ExternalField: DefaultExternalField,
}

type TranslationLayerSpec struct {
	PackageName  string
	Name         string
	APIImpl      any
	APIName      string
	ExternalType any
	InternalType any
}

type TranslationLayerSettings struct {
	ExternalName  string
	ImportAlias   string
	APIField      string
	WrapperField  string
	WrapperType   string
	ExternalField string
	InternalField string
}

type TranslationLayer struct {
	PackageName string
	WrappedType *WrappedType
}

func NewTranslationLayer(tls *TranslationLayerSpec, settings TranslationLayerSettings) *TranslationLayer {
	apiType := reflect.TypeOf(tls.APIImpl)
	if apiType.NumMethod() < 1 {
		panic(fmt.Sprintf("API must have methods (be an interface), but got %v with no methods", apiType.Kind()))
	}
	pkgPath := apiType.PkgPath()
	if apiType.Kind() == reflect.Pointer {
		pkgPath = apiType.Elem().PkgPath()
	}
	internalType := reflect.TypeOf(tls.InternalType)
	localPkgPath := internalType.PkgPath()
	if internalType.Kind() == reflect.Pointer {
		localPkgPath = internalType.Elem().PkgPath()
	}
	importAlias := importAlias(settings.ImportAlias, pkgPath)
	wrapperTypeName := wrapper(settings.WrapperType, tls.Name)
	return &TranslationLayer{
		PackageName: tls.PackageName,
		WrappedType: &WrappedType{
			Translation: Translation{
				Lib:          Import{Alias: importAlias, Path: pkgPath},
				ExternalName: settings.ExternalName,
				External:     NewDataTypeFromReflect(settings.ExternalField, reflect.TypeOf(tls.ExternalType)),
				ExternalAPI:  NewNamedType(settings.APIField, tls.APIName),
				Internal: NewDataTypeFromReflect(
					settings.InternalField, reflect.TypeOf(tls.InternalType),
				).StripLocalPackage(localPkgPath),
				Wrapper: NewNamedType(settings.WrapperField, wrapperTypeName),
			},
			WrapperMethods: []WrapperMethod{},
		},
	}
}

func importAlias(alias, pkgPath string) string {
	if alias == Auto {
		base := filepath.Base(pkgPath)
		return base
	}
	return alias
}

func wrapper(wrapperName, fallback string) string {
	if wrapperName == Auto {
		return fallback
	}
	return wrapperName
}

func (tl *TranslationLayer) Generate() (string, error) {
	if tl == nil {
		return "", ErrNilSpec
	}
	if tl.isEmpty() {
		return "", ErrEmptySpec
	}
	f := jen.NewFile(tl.PackageName)
	f.HeaderComment(CodeGenBanner)
	if tl.WrappedType != nil {
		if err := tl.WrappedType.generate(f); err != nil {
			return "", fmt.Errorf("failed to generate wrapper type: %w", err)
		}
		conversion := NewConversion(
			tl.WrappedType.ExternalName,
			tl.WrappedType.External,
			tl.WrappedType.Internal,
		)
		if err := conversion.generate(f); err != nil {
			return "", fmt.Errorf("failed to generate conversion functions: %w", err)
		}
		f.Comment(CodeGenBanner)
	}
	return f.GoString(), nil
}

func (tl *TranslationLayer) isEmpty() bool {
	return tl.PackageName == "" && tl.WrappedType == nil
}
