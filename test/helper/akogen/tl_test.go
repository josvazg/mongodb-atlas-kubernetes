package akogen_test

import (
	"crypto/rand"
	"fmt"
	"log"
	"math/big"
	"os"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/tools/go/packages"

	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/metadata"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/sample"
)

const (
	wrappedCallSample = `// Generated by AKOGen code Generator - do not edit

package %s

import (
	"context"
	pointer "github.com/mongodb/mongodb-atlas-kubernetes/v2/internal/pointer"
	"github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib"
)

type wrapper struct {
	api lib.API
}

func (w *wrapper) Create(ctx context.Context, r *Resource) (*Resource, error) {
	libR, err := w.api.Create(ctx, toAtlas(r))
	if err != nil {
		return nil, err
	}
	return fromAtlas(libR), nil
}

func (w *wrapper) Get(ctx context.Context, s string) (*Resource, error) {
	libR, err := w.api.Get(ctx, s)
	if err != nil {
		return nil, err
	}
	return fromAtlas(libR), nil
}

func toAtlas(r *Resource) *lib.Resource {
	if r == nil {
		return nil
	}
	return &lib.Resource{
		ComplexSubtype: complexSubtypeToAtlas(r.ComplexSubtype),
		Enabled:        pointer.MakePtr(r.Enabled),
		Id:             r.ID,
		OptionalRef:    optionalRefToAtlas(r.OptionalRef),
		SelectedOption: pointer.MakePtr(string(r.SelectedOption)),
		Status:         pointer.MakePtr(r.Status),
	}
}

func fromAtlas(libR *lib.Resource) *Resource {
	if libR == nil {
		return nil
	}
	return &Resource{
		ComplexSubtype: complexSubtypeFromAtlas(libR.ComplexSubtype),
		Enabled:        pointer.GetOrDefault(libR.Enabled, false),
		ID:             libR.Id,
		OptionalRef:    optionalRefFromAtlas(libR.OptionalRef),
		SelectedOption: OptionType(pointer.GetOrDefault(libR.SelectedOption, "")),
		Status:         pointer.GetOrDefault(libR.Status, ""),
	}
}

func complexSubtypeToAtlas(cs ComplexSubtype) lib.ComplexSubtype {
	return lib.ComplexSubtype{
		Name:    cs.Name,
		Subtype: string(cs.Subtype),
	}
}

func complexSubtypeFromAtlas(libCs lib.ComplexSubtype) ComplexSubtype {
	return ComplexSubtype{
		Name:    libCs.Name,
		Subtype: Subtype(libCs.Subtype),
	}
}

func optionalRefToAtlas(or *OptionalRef) *lib.OptionalRef {
	if or == nil {
		return nil
	}
	return &lib.OptionalRef{Ref: or.Ref}
}

func optionalRefFromAtlas(libOr *lib.OptionalRef) *OptionalRef {
	if libOr == nil {
		return nil
	}
	return &OptionalRef{Ref: libOr.Ref}
}

// Generated by AKOGen code Generator - do not edit
`
)

func fullSample(packageName string) *akogen.TranslationLayer {
	return &akogen.TranslationLayer{
		PackageName: packageName,
		WrappedType: &akogen.WrappedType{
			Translation: akogen.Translation{
				Lib: metadata.Import{
					Alias: "lib",
					Path:  "github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib",
				},
				ExternalName: "Atlas",
				External: metadata.NewStruct(
					metadata.NewNamedType("libR", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.Resource"),
					metadata.NewStructField(
						"ComplexSubtype",
						metadata.NewNamedType("libCs", "github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.ComplexSubtype"),
						metadata.NewSimpleField("Name", "string"),
						metadata.NewSimpleField("Subtype", "string"),
					),
					metadata.NewSimpleField("Enabled", "*bool"),
					metadata.NewSimpleField("Id", "string"),
					metadata.NewStructField(
						"OptionalRef",
						metadata.NewNamedType("libOr", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.OptionalRef"),
						metadata.NewSimpleField("Ref", "string"),
					),
					metadata.NewSimpleField("SelectedOption", "*string"),
					metadata.NewSimpleField("Status", "*string"),
				),
				ExternalAPI: metadata.NewNamedType("api", "API"),
				Internal: metadata.NewStruct(
					metadata.NewNamedType("r", "*Resource"),
					metadata.NewStructField(
						"ComplexSubtype",
						metadata.NewNamedType("cs", "ComplexSubtype"),
						metadata.NewSimpleField("Name", "string"),
						metadata.NewSimpleField("Subtype", "Subtype").WithPrimitive("string"),
					),
					metadata.NewSimpleField("Enabled", "bool"),
					metadata.NewSimpleField("ID", "string"),
					metadata.NewStructField(
						"OptionalRef",
						metadata.NewNamedType("or", "*OptionalRef"),
						metadata.NewSimpleField("Ref", "string"),
					),
					metadata.NewSimpleField("SelectedOption", "OptionType").WithPrimitive("string"),
					metadata.NewSimpleField("Status", "string"),
				),
				Wrapper: metadata.NewNamedType("w", "wrapper"),
			},
			WrapperMethods: []akogen.WrapperMethod{
				{
					MethodSignature: metadata.MethodSignature{
						Receiver: metadata.NewNamedType("w", "*wrapper"),
						FunctionSignature: metadata.FunctionSignature{
							Name: "Create",
							Args: []metadata.NamedType{
								metadata.NewNamedType("ctx", "context.Context"),
								metadata.NewNamedType("r", "*Resource"),
							},
							Returns: []metadata.NamedType{
								metadata.NewNamedType("r", "*Resource"),
								metadata.NewNamedType("err", "error"),
							},
						},
					},
					WrappedCall: metadata.FunctionSignature{
						Name: "Create",
						Args: []metadata.NamedType{
							metadata.NewNamedType("ctx", "context.Context"),
							metadata.NewNamedType("libR", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.Resource"),
						},
						Returns: []metadata.NamedType{
							metadata.NewNamedType("libR", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.Resource"),
							metadata.NewNamedType("err", "error"),
						},
					},
				},
				{
					MethodSignature: metadata.MethodSignature{
						Receiver: metadata.NewNamedType("w", "*wrapper"),
						FunctionSignature: metadata.FunctionSignature{
							Name: "Get",
							Args: metadata.NamedTypes{
								metadata.NewNamedType("ctx", "context.Context"),
								metadata.NewNamedType("s", "string"),
							},
							Returns: metadata.NamedTypes{
								metadata.NewNamedType("r", "*Resource"),
								metadata.NewNamedType("err", "error"),
							},
						},
					},
					WrappedCall: metadata.FunctionSignature{
						Name: "Get",
						Args: []metadata.NamedType{
							metadata.NewNamedType("ctx", "context.Context"),
							metadata.NewNamedType("s", "string"),
						},
						Returns: []metadata.NamedType{
							metadata.NewNamedType("libR", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.Resource"),
							metadata.NewNamedType("err", "error"),
						},
					},
				},
			},
		},
	}
}

func fullSampleFromReflect(packageName string) *akogen.TranslationLayer {
	defaults := akogen.DefaultSettings
	defaults.ExternalName = "Atlas"
	defaults.WrapperType = "wrapper"

	return akogen.NewTranslationLayer(&akogen.TranslationLayerSpec{
		PackageName:  packageName,
		Name:         "Resource",
		API:          reflect.TypeOf((*lib.API)(nil)).Elem(),
		ExternalType: &lib.Resource{},
		InternalType: &sample.Resource{},
	}, defaults)
}

// func fullASTSample() *akogen.TranslationLayer {
// 	return &akogen.TranslationLayer{
// 		PackageName: "sample",
// 		WrappedType: &akogen.WrappedType{
// 			Translation: akogen.Translation{
// 				Lib: metadata.Import{
// 					Alias: "lib",
// 					Path:  "github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib",
// 				},
// 				ExternalName: "Atlas",
// 				External: metadata.NewStruct(
// 					metadata.NewNamedType("res", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.Resource"),
// 					metadata.NewStructField(
// 						"ComplexSubtype",
// 						metadata.NewNamedType("libCs", "github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.ComplexSubtype"),
// 						metadata.NewSimpleField("Name", "string"),
// 						metadata.NewSimpleField("Subtype", "string"),
// 					),
// 					metadata.NewSimpleField("Enabled", "*bool"),
// 					metadata.NewSimpleField("Id", "string"),
// 					metadata.NewStructField(
// 						"OptionalRef",
// 						metadata.NewNamedType("libOr", "*github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.OptionalRef"),
// 						metadata.NewSimpleField("Ref", "string"),
// 					),
// 					metadata.NewSimpleField("SelectedOption", "*string"),
// 					metadata.NewSimpleField("Status", "*string"),
// 				),
// 				ExternalAPI: metadata.NewNamedType("api", "github.com/mongodb/mongodb-atlas-kubernetes/v2/test/helper/akogen/lib.API"),
// 				Internal: metadata.NewStruct(
// 					metadata.NewNamedType("res", "*Resource"),
// 					metadata.NewStructField(
// 						"ComplexSubtype",
// 						metadata.NewNamedType("ComplexSubtype", "ComplexSubtype"),
// 						metadata.NewSimpleField("Name", "string"),
// 						metadata.NewSimpleField("Subtype", "Subtype").WithPrimitive("string"),
// 					),
// 					metadata.NewSimpleField("Enabled", "bool"),
// 					metadata.NewSimpleField("ID", "string"),
// 					metadata.NewStructField(
// 						"OptionalRef",
// 						metadata.NewNamedType("OptionalRef", "*OptionalRef"),
// 						metadata.NewSimpleField("Ref", "string"),
// 					),
// 					metadata.NewSimpleField("SelectedOption", "OptionType").WithPrimitive("string"),
// 					metadata.NewSimpleField("Status", "string"),
// 				),
// 				Wrapper: metadata.NewNamedType("w", "Wrapper"),
// 			},
// 		},
// 	}
// }

// broken
// func TestNewTranslationLayerAST(t *testing.T) {
// 	want := fullASTSample()
// 	got, err := akogen.NewTranslationLayerFromSourceFile("sample/def.go")
// 	require.NoError(t, err)
// 	assert.Equal(t, want, got)
// }

func TestNewTranslationLayer(t *testing.T) {
	packageName := "sample"
	want := fullSample(packageName)
	got := fullSampleFromReflect(packageName)
	assert.Equal(t, want, got)
}

func TestGenerateTranslationLayer(t *testing.T) {
	packageName := randomString(t, "prefix")
	for _, tc := range []struct {
		title     string
		spec      *akogen.TranslationLayer
		want      string
		wantError error
	}{
		{
			title:     "nil spec fails",
			wantError: akogen.ErrNilSpec,
		},
		{
			title:     "empty spec fails",
			spec:      &akogen.TranslationLayer{},
			wantError: akogen.ErrEmptySpec,
		},
		{
			title: "setting just the package generates source of such package",
			spec: &akogen.TranslationLayer{
				PackageName: packageName,
			},
			want: fmt.Sprintf("// Generated by AKOGen code Generator - do not edit\n\npackage %s\n", packageName),
		},
		{
			title: "specifying a full sample wrapper generates the expected wrapper code",
			spec:  fullSample(packageName),
			want:  fmt.Sprintf(wrappedCallSample, packageName),
		},
		{
			title: "specifying a full sample wrapper from code and reflection generates the expected wrapper code",
			spec:  fullSampleFromReflect(packageName),
			want:  fmt.Sprintf(wrappedCallSample, packageName),
		},
	} {
		t.Run(tc.title, func(t *testing.T) {
			src, err := tc.spec.Generate()
			if tc.wantError != nil {
				require.Empty(t, src)
				assert.Equal(t, tc.wantError, err)
				return
			}
			require.NoError(t, err)
			assert.Equal(t, tc.want, src)
		})
	}
}

func TestTranslationLayerGenerateFile(t *testing.T) {
	packageName := "sample"
	tl := fullSample(packageName)
	srcCode, err := tl.Generate()
	require.NoError(t, err)
	err = os.WriteFile("sample/generated.go", ([]byte)(srcCode), 0600)
	require.NoError(t, err)
}

func TestLoadPackages(t *testing.T) {
	packageName, err := akogen.GetFQPath("sample/def.go")
	require.NoError(t, err)
	cfg := &packages.Config{Mode: packages.NeedFiles |
		packages.NeedSyntax |
		packages.NeedTypes |
		packages.NeedTypesInfo |
		packages.NeedDeps |
		packages.NeedImports}
	pkgs, err := packages.Load(cfg, packageName)
	require.NoError(t, err)
	assert.NotEmpty(t, pkgs)
	for _, pkg := range pkgs {
		log.Printf("Pkg id %s", pkg.ID)
		log.Printf("Pkg path %v", pkg.PkgPath)
		log.Printf("Pkg files %v", pkg.GoFiles)
		log.Printf("Pkg types %v", pkg.Types)
		log.Printf("Pkg type infos %v", pkg.TypesInfo)
		log.Printf("Pkg complete %v", pkg.Types.Complete())
	}
}

func randomString(t *testing.T, prefix string) string {
	n, err := rand.Int(rand.Reader, big.NewInt(99999))
	require.NoError(t, err)
	return fmt.Sprintf("%s%d", prefix, n.Int64())
}
